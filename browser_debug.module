<?php
/**
 * @file
 * Debugs session and logs to JavaScript console.
 *
 * To configure log files run the following command from root of Drupal site
 * amending log file paths as appropriate:
 * drush vset browser_debug_logs "/var/log/one.log,/var/log/two.log"
 */

/**
 * Implements hook_boot().
 *
 * Gather log positions.
 */
function browser_debug_boot() {
  BrowserDebug::boot();
}

/**
 * Implements hook_ajax_render_alter().
 *
 * Add our own completion command to trigger client side actions.
 */
function browser_debug_ajax_render_alter(&$commands) {
  $commands[] = array('command' => 'browserDebugAjaxComplete', 'arguments' => BrowserDebug::getAllData());
}

/**
 * Implements hook_js_alter().
 *
 * Populate client side data in Drupal.settings.
 */
function browser_debug_js_alter() {
  drupal_add_js(array('browserDebug' => BrowserDebug::getAllData()), 'setting');
}

function bd($item, $label = '') {
  BrowserDebug::addToLog($item, $label);
}

class BrowserDebug {

  private static $log = array();
  private static $settings;

  private static function getSettings() {
    $logs = variable_get('browser_debug_logs', array());
    $logs = explode(',', $logs);
    // Make array of with log path as key and 0 as value;
    $logs = array_combine($logs, array_pad(array(), count($logs), 0));
    $settings = variable_get('browser_debug_settings', array());
    // Create default array structure.
    $default = array('watchdog' => 0, 'logs' => $logs);
    // Add missing.
    $settings = array_replace_recursive($default, $settings);
    // Remove extra.
    $settings['logs'] = array_intersect_key($settings['logs'], $logs);
    bd($settings['watchdog'], 'settings.watchdog (get)');
    bd($settings['logs'], 'settings.logs (get)');
    self::$settings = $settings;
  }

  private static function saveSettings() {
    bd(self::$settings['watchdog'], 'settings.watchdog (set)');
    bd(self::$settings['logs'], 'settings.logs (set)');
    variable_set('browser_debug_settings', self::$settings);
  }

  public static function boot() {
    self::getSettings();
    if($settings['watchdog'] === 0) {
      $settings['watchdog'] = self::getWatchdogPosition();
    }
  }

  public static function addToLog($item, $label) {
    switch (TRUE) {
      case empty($label):
        self::$log[] = $item;
        break;

      case is_string($item):
        self::$log[] = $label . ': ' . $item;
        break;

      default:
        self::$log[] = $label . ':';
        self::$log[] = $item;
        break;
    }
  }

  public static function getAllData() {
    $data = array(
      'session' => self::getSession(),
      'watchdog' => self::getWatchdogLog(),
    );
    self::saveSettings();
    // Add log, done as last step to enable internal logging until the last moment!
    $data['log'] = self::$log;
    return $data;
  }

  public static function getWatchdogPosition() {
    $wid = (int) db_query('select max(wid) from watchdog;')->fetchField();
    return $wid;
  }

  private static function getWatchdogLog() {
    $wid = self::getWatchdogPosition();
    $last_wid = self::$settings['watchdog'];
    self::$settings['watchdog'] = $wid;

    $query = db_select('watchdog', 'w')->extend('PagerDefault')->extend('TableSort');
    $query->leftJoin('users', 'u', 'w.uid = u.uid');
    $query
      ->fields('w', array('wid', 'uid', 'severity', 'type', 'timestamp', 'message', 'variables', 'link'))
      ->addField('u', 'name');

    $result = $query
      ->condition('wid', array($last_wid, $wid), 'BETWEEN')
      ->limit(500)
      ->orderBy('wid', 'desc')
      ->execute();

    $rows = array();
    foreach ($result as $dblog) {

      $serialized_false = serialize(FALSE);
      @$vars = unserialize($dblog->variables);
      if (!isset($vars) || ($vars === FALSE && $value !== $serialized_false)) {
        $message = strip_tags(decode_entities($dblog->message));
      }
      else {
        $message = strip_tags(decode_entities(t($dblog->message, $vars)));
      }

      $row = array(
        format_date($dblog->timestamp, 'short'),
        $dblog->type,
        $message,
        $dblog->name,
      );

      $rows[] = implode(' : ', $row);

    }

    return array('watchdog' => $rows);
  }

  private function getSession() {
    $session  = array();
    $serialized_false = serialize(FALSE);
    foreach ($_SESSION as $key => $value) {
      @$unserialized = unserialize(is_string($value) ? $value : $serialized_false);
      if ($unserialized === FALSE && $value !== $serialized_false) {
        $session[$key] = $value;
      }
      else {
        $session[$key] = $unserialized;
      }
    }
    return $session;
  }

  private static function convertArrayToObject($array) {
    $object = new stdClass();
    foreach ($array as $key => $value) {
      $object->$key = $value;
    }
    return $object;
  }

}
